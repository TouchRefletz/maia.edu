name: Delete Artifact (Cleanup)

on:
  repository_dispatch:
    types: [delete-artifact]
  workflow_dispatch:
    inputs:
      slug:
        description: 'Slug to delete (e.g. "enem-2022")'
        required: true
      filename:
        description: 'Specific filename to delete (e.g. "files/prova.pdf")'
        required: true

jobs:
  delete:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    env:
      SLUG: ${{ github.event.client_payload.slug || inputs.slug }}
      FILENAME: ${{ github.event.client_payload.filename || inputs.filename }}
      PUSHER_APP_ID: ${{ secrets.PUSHER_APP_ID }}
      PUSHER_KEY: ${{ secrets.PUSHER_KEY }}
      PUSHER_SECRET: ${{ secrets.PUSHER_SECRET }}
      PUSHER_CLUSTER: ${{ secrets.PUSHER_CLUSTER }}

    steps:
      - name: Setup Logger
        run: |
          cat << 'EOF' > logger.py
          import sys
          import time
          import json
          import hashlib
          import hmac
          import os
          import threading
          import http.client
          import urllib.parse
          from collections import deque

          # Config
          PUSHER_APP_ID = os.environ.get("PUSHER_APP_ID")
          PUSHER_KEY = os.environ.get("PUSHER_KEY")
          PUSHER_SECRET = os.environ.get("PUSHER_SECRET")
          PUSHER_CLUSTER = os.environ.get("PUSHER_CLUSTER")
          CHANNEL = os.environ.get("SLUG")

          if not all([PUSHER_APP_ID, PUSHER_KEY, PUSHER_SECRET, PUSHER_CLUSTER, CHANNEL]):
              print("Missing Pusher secrets. Logging to stdout only.")
              for line in sys.stdin:
                  sys.stdout.write(line)
                  sys.stdout.flush()
              sys.exit(0)

          # Buffer
          log_buffer = deque()
          buffer_lock = threading.Lock()
          running = True

          def send_batch(lines):
              if not lines:
                  return
              
              timestamp = str(int(time.time()))
              text_chunk = "".join(lines)
              
              body_data = json.dumps({"message": text_chunk})
              body = json.dumps({
                  "name": "log",
                  "channels": [CHANNEL],
                  "data": body_data
              })
              
              body_md5 = hashlib.md5(body.encode('utf-8')).hexdigest()
              
              sign_string = f"POST\n/apps/{PUSHER_APP_ID}/events\nauth_key={PUSHER_KEY}&auth_timestamp={timestamp}&auth_version=1.0&body_md5={body_md5}"
              auth_signature = hmac.new(PUSHER_SECRET.encode('utf-8'), sign_string.encode('utf-8'), hashlib.sha256).hexdigest()
              
              params = urllib.parse.urlencode({
                  'auth_key': PUSHER_KEY,
                  'auth_timestamp': timestamp,
                  'auth_version': '1.0',
                  'body_md5': body_md5,
                  'auth_signature': auth_signature
              })
              
              try:
                  conn = http.client.HTTPSConnection(f"api-{PUSHER_CLUSTER}.pusher.com", timeout=3)
                  headers = {'Content-Type': 'application/json'}
                  conn.request("POST", f"/apps/{PUSHER_APP_ID}/events?{params}", body, headers)
                  resp = conn.getresponse()
                  resp.read()
                  conn.close()
              except Exception as e:
                  print(f"Pusher Error: {e}")

          def consumer_thread():
              while running or log_buffer:
                  with buffer_lock:
                      if not log_buffer:
                          batch = []
                      else:
                          batch = list(log_buffer)
                          log_buffer.clear()
                  
                  if batch:
                      send_batch(batch)
                  time.sleep(1.0)

          t = threading.Thread(target=consumer_thread)
          t.daemon = True
          t.start()

          for line in sys.stdin:
              sys.stdout.write(line)
              sys.stdout.flush()
              with buffer_lock:
                  log_buffer.append(line)

          running = False
          t.join(timeout=5)
          EOF

      - name: Announce Job URL
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RUN_ID: ${{ github.run_id }}
          REPO: ${{ github.repository }}
        run: |
          (
            JOBS_JSON=$(curl -s -H "Authorization: Bearer $GH_TOKEN" "https://api.github.com/repos/$REPO/actions/runs/$RUN_ID/jobs")
            JOB_URL=$(echo "$JOBS_JSON" | jq -r '.jobs[0].html_url')
            if [ "$JOB_URL" == "null" ] || [ -z "$JOB_URL" ]; then
                JOB_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            fi
            echo "[SYSTEM_INFO] JOB_URL=$JOB_URL"
          ) 2>&1 | python3 logger.py

      - name: Cleanup Hugging Face (Specific File)
        env:
          HF_TOKEN: ${{ secrets.HF_TOKEN }}
        run: |
          (
            echo "INICIANDO REMOÇÃO do arquivo corrompido: $FILENAME (Slug: $SLUG)..."
            
            git config --global user.email "bot@maia.api"
            git config --global user.name "Maia Bot"

            # Clone Repo
            git clone --depth 1 https://user:$HF_TOKEN@huggingface.co/datasets/toquereflexo/maia-deep-search hf_cleanup_repo
            cd hf_cleanup_repo

            # Path Checks
            BASE_DIR="output/$SLUG"
            FILE_PATH="$BASE_DIR/$FILENAME"
            FILES_SUBDIR_PATH="$BASE_DIR/files/$FILENAME"
            MANIFEST_PATH="$BASE_DIR/manifest.json"

            TARGET_TO_REMOVE=""

            if [ -f "$FILE_PATH" ]; then
                TARGET_TO_REMOVE="$FILE_PATH"
            elif [ -f "$FILES_SUBDIR_PATH" ]; then
                TARGET_TO_REMOVE="$FILES_SUBDIR_PATH"
            fi

            if [ -n "$TARGET_TO_REMOVE" ]; then
                echo "Arquivo encontrado. Removendo: $TARGET_TO_REMOVE"
                git rm "$TARGET_TO_REMOVE"

                # Check for Thumbnail
                # We extract the filename from the path we just removed
                REMOVED_FILENAME=$(basename "$TARGET_TO_REMOVE")
                # Remove extension (assuming .pdf)
                STEM="${REMOVED_FILENAME%.*}"
                THUMB_PATH="$BASE_DIR/thumbnails/${STEM}.jpg"

                if [ -f "$THUMB_PATH" ]; then
                    echo "Thumbnail encontrada. Removendo: $THUMB_PATH"
                    git rm "$THUMB_PATH"
                else
                     echo "Thumbnail não encontrada em: $THUMB_PATH (Pode não existir)"
                fi
                
                if [ -f "$MANIFEST_PATH" ]; then
                    echo "Atualizando manifest.json..."
                    # Python script to safely remove entry from manifest
                    python3 <<PY_SCRIPT
          import json
          import sys
          import os

          try:
              with open("$MANIFEST_PATH", "r", encoding="utf-8") as f:
                  data = json.load(f)

              # Normalize filename for comparison
              target = "$FILENAME"
              # Handle "files/" prefix if present in target but not in manifest or vice-versa
              target_base = target.replace("files/", "") if target.startswith("files/") else target
              
              print(f"Alvo para remoção (Strict): {target} (Base: {target_base})")

              # Helper to calculate new list
              new_data = []
              
              # Handle robustly common structures (Array or Object with results)
              # Assumption: data is Array or { results: [...] }
              
              items = []
              is_wrapped = False
              
              if isinstance(data, list):
                  items = data
              elif isinstance(data, dict) and "results" in data:
                  items = data["results"]
                  is_wrapped = True
              elif isinstance(data, dict) and "files" in data:
                  items = data["files"]
                  is_wrapped = True
              
              # Filter Logic
              start_len = len(items)
              filtered_items = []
              
              for item in items:
                  # Check various filename properties
                  fname = item.get("filename", "")
                  path = item.get("path", "")
                  
                  # Strict Equality Checks
                  # We check both full path and basename to be safe, but NO wildcards/endswith
                  is_match = (
                      fname == target or 
                      fname == target_base or 
                      path == target or 
                      path == target_base or
                      # Handle case where manifest has "files/foo.pdf" and target is "foo.pdf"
                      (fname == "files/" + target_base) or
                      (path == "files/" + target_base)
                  )
                  
                  if is_match:
                      print(f"REMOVENDO entrada do manifesto: {fname} (Match Exato)")
                      continue # Skip (Delete)

                  filtered_items.append(item)
              
              end_len = len(filtered_items)
              print(f"Total itens antes: {start_len}, depois: {end_len}")

              if is_wrapped:
                  data["results"] = filtered_items # Maintain wrapper structure if used
                  final_json = data
              else:
                  final_json = filtered_items

              with open("$MANIFEST_PATH", "w", encoding="utf-8") as f:
                  json.dump(final_json, f, indent=2, ensure_ascii=False)
                  
          except Exception as e:
              print(f"Erro ao processar manifesto: {e}")
              sys.exit(1)
          PY_SCRIPT

                    git add "$MANIFEST_PATH"
                else
                    echo "Manifesto não encontrado, apenas o arquivo foi removido."
                fi

                git commit -m "Cleanup (Corrupt PDF): $FILENAME"
                git push
                echo "SUCESSO: Arquivo removido e manifesto atualizado."
            else
                echo "AVISO: Arquivo $FILENAME não encontrado no repositório. Talvez já tenha sido removido?"
            fi
            
            cd ..
            rm -rf hf_cleanup_repo

          ) 2>&1 | python3 logger.py

      - name: Notify Completion
        if: ${{ always() }}
        env:
          JOB_STATUS: ${{ job.status }}
        run: |
          (
            if [ "$JOB_STATUS" == "success" ]; then
               echo "COMPLETED"
            else
               echo "FAILED"
            fi
          ) 2>&1 | python3 logger.py
