name: Delete Artifact (Cleanup)

on:
  repository_dispatch:
    types: [delete-artifact]
  workflow_dispatch:
    inputs:
      slug:
        description: 'Slug to delete (e.g. "enem-2022")'
        required: true
      filename:
        description: 'Specific filename to delete (e.g. "files/prova.pdf")'
        required: true

jobs:
  delete:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    env:
      SLUG: ${{ github.event.client_payload.slug || inputs.slug }}
      FILENAME: ${{ github.event.client_payload.filename || inputs.filename }}
      PUSHER_APP_ID: ${{ secrets.PUSHER_APP_ID }}
      PUSHER_KEY: ${{ secrets.PUSHER_KEY }}
      PUSHER_SECRET: ${{ secrets.PUSHER_SECRET }}
      PUSHER_CLUSTER: ${{ secrets.PUSHER_CLUSTER }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Logger
        run: |
          cat << 'EOF' > logger.py
          import sys
          import time
          import json
          import hashlib
          import hmac
          import os
          import threading
          import http.client
          import urllib.parse
          from collections import deque

          # Config
          PUSHER_APP_ID = os.environ.get("PUSHER_APP_ID")
          PUSHER_KEY = os.environ.get("PUSHER_KEY")
          PUSHER_SECRET = os.environ.get("PUSHER_SECRET")
          PUSHER_CLUSTER = os.environ.get("PUSHER_CLUSTER")
          CHANNEL = os.environ.get("SLUG")

          if not all([PUSHER_APP_ID, PUSHER_KEY, PUSHER_SECRET, PUSHER_CLUSTER, CHANNEL]):
              print("Missing Pusher secrets. Logging to stdout only.")
              for line in sys.stdin:
                  sys.stdout.write(line)
                  sys.stdout.flush()
              sys.exit(0)

          # Buffer
          log_buffer = deque()
          buffer_lock = threading.Lock()
          running = True

          def send_batch(lines):
              if not lines:
                  return
              
              timestamp = str(int(time.time()))
              text_chunk = "".join(lines)
              
              body_data = json.dumps({"message": text_chunk})
              body = json.dumps({
                  "name": "log",
                  "channels": [CHANNEL],
                  "data": body_data
              })
              
              body_md5 = hashlib.md5(body.encode('utf-8')).hexdigest()
              
              sign_string = f"POST\n/apps/{PUSHER_APP_ID}/events\nauth_key={PUSHER_KEY}&auth_timestamp={timestamp}&auth_version=1.0&body_md5={body_md5}"
              auth_signature = hmac.new(PUSHER_SECRET.encode('utf-8'), sign_string.encode('utf-8'), hashlib.sha256).hexdigest()
              
              params = urllib.parse.urlencode({
                  'auth_key': PUSHER_KEY,
                  'auth_timestamp': timestamp,
                  'auth_version': '1.0',
                  'body_md5': body_md5,
                  'auth_signature': auth_signature
              })
              
              try:
                  conn = http.client.HTTPSConnection(f"api-{PUSHER_CLUSTER}.pusher.com", timeout=3)
                  headers = {'Content-Type': 'application/json'}
                  conn.request("POST", f"/apps/{PUSHER_APP_ID}/events?{params}", body, headers)
                  resp = conn.getresponse()
                  resp.read()
                  conn.close()
              except Exception as e:
                  print(f"Pusher Error: {e}")

          def consumer_thread():
              while running or log_buffer:
                  with buffer_lock:
                      if not log_buffer:
                          batch = []
                      else:
                          batch = list(log_buffer)
                          log_buffer.clear()
                  
                  if batch:
                      send_batch(batch)
                  time.sleep(1.0)

          t = threading.Thread(target=consumer_thread)
          t.daemon = True
          t.start()

          for line in sys.stdin:
              sys.stdout.write(line)
              sys.stdout.flush()
              with buffer_lock:
                  log_buffer.append(line)

          running = False
          t.join(timeout=5)
          EOF

      - name: Announce Job URL
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RUN_ID: ${{ github.run_id }}
          REPO: ${{ github.repository }}
        run: |
          (
            JOBS_JSON=$(curl -s -H "Authorization: Bearer $GH_TOKEN" "https://api.github.com/repos/$REPO/actions/runs/$RUN_ID/jobs")
            JOB_URL=$(echo "$JOBS_JSON" | jq -r '.jobs[0].html_url')
            if [ "$JOB_URL" == "null" ] || [ -z "$JOB_URL" ]; then
                JOB_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            fi
            echo "[SYSTEM_INFO] JOB_URL=$JOB_URL"
          ) 2>&1 | python3 logger.py

      - name: Cleanup Hugging Face (Specific File)
        env:
          HF_TOKEN: ${{ secrets.HF_TOKEN }}
        run: |
          (
            echo "INICIANDO REMOÇÃO do arquivo corrompido: $FILENAME (Slug: $SLUG)..."
            
            git config --global user.email "bot@maia.api"
            git config --global user.name "Maia Bot"

            # Clone Repo
            git clone --depth 1 https://user:$HF_TOKEN@huggingface.co/datasets/toquereflexo/maia-deep-search hf_cleanup_repo
            cd hf_cleanup_repo

            # Path Checks
            BASE_DIR="output/$SLUG"
            FILE_PATH="$BASE_DIR/$FILENAME"
            FILES_SUBDIR_PATH="$BASE_DIR/files/$FILENAME"
            MANIFEST_PATH="$BASE_DIR/manifest.json"

            TARGET_TO_REMOVE=""

            if [ -f "$FILE_PATH" ]; then
                TARGET_TO_REMOVE="$FILE_PATH"
            elif [ -f "$FILES_SUBDIR_PATH" ]; then
                TARGET_TO_REMOVE="$FILES_SUBDIR_PATH"
            fi

            SHOULD_UPDATE_MANIFEST="false"

            if [ -n "$TARGET_TO_REMOVE" ]; then
                echo "Arquivo encontrado. Removendo: $TARGET_TO_REMOVE"
                git rm "$TARGET_TO_REMOVE"
                SHOULD_UPDATE_MANIFEST="true"

                # Check for Thumbnail
                REMOVED_FILENAME=$(basename "$TARGET_TO_REMOVE")
                STEM="${REMOVED_FILENAME%.*}"
                THUMB_PATH="$BASE_DIR/thumbnails/${STEM}.jpg"

                if [ -f "$THUMB_PATH" ]; then
                    echo "Thumbnail encontrada. Removendo: $THUMB_PATH"
                    git rm "$THUMB_PATH"
                else
                     echo "Thumbnail não encontrada em: $THUMB_PATH (Pode não existir)"
                fi
            else
                echo "AVISO: Arquivo $FILENAME (ou variantes) não encontrado no repositório."
                # Se não achou arquivo, mas veio o comando de delete, assumimos que é para limpar
                # o manifesto se estivermos no fluxo de 'manifest_only' ou apenas para garantir integridade.
                # A flag client_payload.manifest_only poderia ser usada, mas para simplificar:
                # Se o usuário pediu para deletar e não tem arquivo, PROVAVELMENTE é um link de referência ou erro de sync.
                # Vamos forçar a atualização do manifesto.
                echo "Habilitando limpeza de MANIFESTO para remover referências órfãs."
                SHOULD_UPDATE_MANIFEST="true"
            fi
            
            if [ "$SHOULD_UPDATE_MANIFEST" == "true" ] && [ -f "$MANIFEST_PATH" ]; then
                echo "Atualizando manifest.json..."
                # Python script to safely remove entry from manifest
                export MANIFEST_PATH="$MANIFEST_PATH"
                export FILENAME="$FILENAME"
                python3 "$GITHUB_WORKSPACE/.github/scripts/update_manifest.py"

                git add "$MANIFEST_PATH"
            else
                if [ "$SHOULD_UPDATE_MANIFEST" == "true" ]; then
                     echo "ERRO/AVISO: Manifesto não encontrado no path esperado: $MANIFEST_PATH"
                fi
            fi

            # Commit changes (File removal AND/OR Manifest update)
            # Use --allow-empty in case nothing changed but we want to log the attempt?
            # No, if nothing blocked, we might fail commit. Check status.
            if git diff --staged --quiet; then
                echo "Nenhuma mudança para commitar."
            else
                git commit -m "Cleanup: $FILENAME"
                git push
                echo "SUCESSO: Limpeza aplicada."
            fi
            
            cd ..
            rm -rf hf_cleanup_repo

          ) 2>&1 | python3 logger.py

      - name: Notify Completion
        if: ${{ always() }}
        env:
          JOB_STATUS: ${{ job.status }}
        run: |
          (
            if [ "$JOB_STATUS" == "success" ]; then
               echo "COMPLETED"
            else
               echo "FAILED"
            fi
          ) 2>&1 | python3 logger.py
