name: Delete Artifact (Cleanup)

on:
  repository_dispatch:
    types: [delete-artifact]
  workflow_dispatch:
    inputs:
      slug:
        description: 'Slug to delete (e.g. "enem-2022")'
        required: true
      filename:
        description: 'Specific filename to delete (e.g. "files/prova.pdf")'
        required: true

jobs:
  delete:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    env:
      SLUG: ${{ github.event.client_payload.slug || inputs.slug }}
      FILENAME: ${{ github.event.client_payload.filename || inputs.filename }}
      # Use toJson to safely pass array as JSON string
      FILENAMES_JSON: ${{ toJson(github.event.client_payload.filenames) }}
      PUSHER_APP_ID: ${{ secrets.PUSHER_APP_ID }}
      PUSHER_KEY: ${{ secrets.PUSHER_KEY }}
      PUSHER_SECRET: ${{ secrets.PUSHER_SECRET }}
      PUSHER_CLUSTER: ${{ secrets.PUSHER_CLUSTER }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Logger
        run: |
          cat << 'EOF' > logger.py
          import sys
          import time
          import json
          import hashlib
          import hmac
          import os
          import threading
          import http.client
          import urllib.parse
          from collections import deque

          # Config
          PUSHER_APP_ID = os.environ.get("PUSHER_APP_ID")
          PUSHER_KEY = os.environ.get("PUSHER_KEY")
          PUSHER_SECRET = os.environ.get("PUSHER_SECRET")
          PUSHER_CLUSTER = os.environ.get("PUSHER_CLUSTER")
          CHANNEL = os.environ.get("SLUG")

          if not all([PUSHER_APP_ID, PUSHER_KEY, PUSHER_SECRET, PUSHER_CLUSTER, CHANNEL]):
              print("Missing Pusher secrets. Logging to stdout only.")
              for line in sys.stdin:
                  sys.stdout.write(line)
                  sys.stdout.flush()
              sys.exit(0)

          # Buffer
          log_buffer = deque()
          buffer_lock = threading.Lock()
          running = True

          def send_batch(lines):
              if not lines:
                  return
              
              timestamp = str(int(time.time()))
              text_chunk = "".join(lines)
              
              body_data = json.dumps({"message": text_chunk})
              body = json.dumps({
                  "name": "log",
                  "channels": [CHANNEL],
                  "data": body_data
              })
              
              body_md5 = hashlib.md5(body.encode('utf-8')).hexdigest()
              
              sign_string = f"POST\n/apps/{PUSHER_APP_ID}/events\nauth_key={PUSHER_KEY}&auth_timestamp={timestamp}&auth_version=1.0&body_md5={body_md5}"
              auth_signature = hmac.new(PUSHER_SECRET.encode('utf-8'), sign_string.encode('utf-8'), hashlib.sha256).hexdigest()
              
              params = urllib.parse.urlencode({
                  'auth_key': PUSHER_KEY,
                  'auth_timestamp': timestamp,
                  'auth_version': '1.0',
                  'body_md5': body_md5,
                  'auth_signature': auth_signature
              })
              
              try:
                  conn = http.client.HTTPSConnection(f"api-{PUSHER_CLUSTER}.pusher.com", timeout=3)
                  headers = {'Content-Type': 'application/json'}
                  conn.request("POST", f"/apps/{PUSHER_APP_ID}/events?{params}", body, headers)
                  resp = conn.getresponse()
                  resp.read()
                  conn.close()
              except Exception as e:
                  print(f"Pusher Error: {e}")

          def consumer_thread():
              while running or log_buffer:
                  with buffer_lock:
                      if not log_buffer:
                          batch = []
                      else:
                          batch = list(log_buffer)
                          log_buffer.clear()
                  
                  if batch:
                      send_batch(batch)
                  time.sleep(1.0)

          t = threading.Thread(target=consumer_thread)
          t.daemon = True
          t.start()

          for line in sys.stdin:
              sys.stdout.write(line)
              sys.stdout.flush()
              with buffer_lock:
                  log_buffer.append(line)

          running = False
          t.join(timeout=5)
          EOF

      - name: Announce Job URL
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RUN_ID: ${{ github.run_id }}
          REPO: ${{ github.repository }}
        run: |
          (
            JOBS_JSON=$(curl -s -H "Authorization: Bearer $GH_TOKEN" "https://api.github.com/repos/$REPO/actions/runs/$RUN_ID/jobs")
            JOB_URL=$(echo "$JOBS_JSON" | jq -r '.jobs[0].html_url')
            if [ "$JOB_URL" == "null" ] || [ -z "$JOB_URL" ]; then
                JOB_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            fi
            echo "[SYSTEM_INFO] JOB_URL=$JOB_URL"
          ) 2>&1 | python3 logger.py

      - name: Cleanup Hugging Face (Batch)
        env:
          HF_TOKEN: ${{ secrets.HF_TOKEN }}
        run: |
          (
            echo "INICIANDO LIMPEZA EM LOTE (Slug: $SLUG)..."
            
            git config --global user.email "bot@maia.api"
            git config --global user.name "Maia Bot"

            # Clone Repo
            git clone --depth 1 https://user:$HF_TOKEN@huggingface.co/datasets/toquereflexo/maia-deep-search hf_cleanup_repo
            cd hf_cleanup_repo

            MAX_RETRIES=10
            success="false"

            for (( i=0; i<MAX_RETRIES; i++ )); do
                 if [ $i -gt 0 ]; then
                    echo "Tentativa $((i+1))/$MAX_RETRIES: Sincronizando (hard reset)..."
                    sleep $(( ( RANDOM % 6 ) + 2 ))
                    git fetch origin main
                    git reset --hard origin/main
                 fi

                 # Create Python Helper to parse filenames
                 # We simply dump the env vars to a file or read them in python
                 cat << 'PYEOF' > batch_targets.py
          import os
          import json

          # Handle both singular FILENAME and plural FILENAMES_JSON
          filenames = []

          singular = os.environ.get("FILENAME")
          if singular and singular != "null":
              filenames.append(singular)

          plural_json = os.environ.get("FILENAMES_JSON")
          if plural_json and plural_json != "null":
              try:
                  parsed = json.loads(plural_json)
                  if isinstance(parsed, list):
                      filenames.extend(parsed)
              except:
                  pass

          # Print newline separated items
          print("\n".join(filenames))
          PYEOF

                 TARGETS=$(python3 batch_targets.py)
                 
                 if [ -z "$TARGETS" ]; then
                     echo "Nenhum arquivo alvo encontrado."
                     success="true"
                     break
                 fi

                 # Process Local Deletions
                 BASE_DIR="output/$SLUG"
                 MANIFEST_PATH="$BASE_DIR/manifest.json"
                 SHOULD_UPDATE_MANIFEST="false"

                 while IFS= read -r FILE_ITEM; do
                      if [ -z "$FILE_ITEM" ]; then continue; fi
                      
                      FILE_PATH="$BASE_DIR/$FILE_ITEM"
                      FILES_SUBDIR_PATH="$BASE_DIR/files/$FILE_ITEM"
                      
                      TARGET_TO_REMOVE=""
                      if [ -f "$FILE_PATH" ]; then
                          TARGET_TO_REMOVE="$FILE_PATH"
                      elif [ -f "$FILES_SUBDIR_PATH" ]; then
                          TARGET_TO_REMOVE="$FILES_SUBDIR_PATH"
                      fi

                      if [ -n "$TARGET_TO_REMOVE" ]; then
                          echo "Removendo: $TARGET_TO_REMOVE"
                          git rm "$TARGET_TO_REMOVE"
                          SHOULD_UPDATE_MANIFEST="true"
                          
                          REMOVED_FILENAME=$(basename "$TARGET_TO_REMOVE")
                          STEM="${REMOVED_FILENAME%.*}"
                          THUMB_PATH="$BASE_DIR/thumbnails/${STEM}.jpg"
                          if [ -f "$THUMB_PATH" ]; then
                             git rm "$THUMB_PATH"
                          fi
                      else
                          # Assumes strict manifest cleanup needed even if file gone
                          SHOULD_UPDATE_MANIFEST="true"
                      fi
                 done <<< "$TARGETS"

                 if [ "$SHOULD_UPDATE_MANIFEST" == "true" ] && [ -f "$MANIFEST_PATH" ]; then
                     echo "Atualizando manifest.json (Batch)..."
                     export MANIFEST_PATH="$MANIFEST_PATH"
                     # Pass filenames to python via env var reused or just FILENAMES_JSON
                     # We need to update update_manifest.py to handle FILENAMES_JSON
                     python3 "$GITHUB_WORKSPACE/.github/scripts/update_manifest.py"
                     git add "$MANIFEST_PATH"
                 fi

                 if git diff --staged --quiet; then
                     echo "Nenhuma mudanÃ§a para commitar."
                     success="true"
                     break
                 fi

                 git commit -m "Cleanup: Batch for $SLUG"
                 
                 if git push origin main; then
                     echo "SUCESSO: Batch clean applied."
                     success="true"
                     break
                 else
                     echo "ALERTA: Push falhou."
                 fi
            done
            
            if [ "$success" != "true" ]; then
                echo "ERRO FATAL."
                exit 1
            fi
            
            cd ..
            rm -rf hf_cleanup_repo

          ) 2>&1 | python3 logger.py

      - name: Notify Completion
        if: ${{ always() }}
        env:
          JOB_STATUS: ${{ job.status }}
        run: |
          (
            if [ "$JOB_STATUS" == "success" ]; then
               echo "COMPLETED"
            else
               echo "FAILED"
            fi
          ) 2>&1 | python3 logger.py
